"""
CommuneX example of an Image Validator Module

This module provides an example ImageValidator class for validating images generated by modules in subnets.
The ImageValidator retrieves module addresses from the subnet, prompts the modules to generate images based on a given prompt,
and scores the generated images by comparing their descriptions to the original prompts using models like BLIP/CLIP and Qwen-2.

Classes:
    ImageValidator: A class for validating images generated by modules in a subnet.

Functions:
    set_weights: Blockchain call to set weights for miners based on their scores.
    cut_to_max_allowed_weights: Cut the scores to the maximum allowed weights.
    extract_address: Extract an address from a string.
    get_subnet_netuid: Retrieve the network UID of the subnet.
    get_ip_port: Get the IP and port information from module addresses.

Constants:
    IP_REGEX: A regular expression pattern for matching IP addresses.
"""

import asyncio
import concurrent.futures
import re
import time
from functools import partial
from PIL import Image
import torch
from transformers import BlipProcessor, BlipForConditionalGeneration, CLIPModel, CLIPProcessor
from communex.client import CommuneClient  # type: ignore
from communex.module.client import ModuleClient  # type: ignore
from communex.module.module import Module  # type: ignore
from communex.types import Ss58Address  # type: ignore
from substrateinterface import Keypair  # type: ignore

from ._config import ValidatorSettings
from ..utils import log

IP_REGEX = re.compile(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+")

class ImageValidator(Module):
    """
    A class for validating images generated by modules in a subnet.

    Attributes:
        client: The CommuneClient instance used to interact with the subnet.
        key: The keypair used for authentication.
        netuid: The unique identifier of the subnet.
        blip_model: The BLIP model used for image-to-text generation.
        clip_model: The CLIP model used for scoring image-prompt relevance.
        call_timeout: The timeout value for module calls in seconds (default: 60).

    Methods:
        get_addresses: Retrieve all module addresses from the subnet.
        _get_miner_image: Prompt a miner module to generate an image based on the given prompt.
        _score_miner: Score the generated image by comparing its description to the prompt.
        get_miner_prompt: Generate a prompt for the miner modules.
        validate_step: Perform a validation step by generating prompts, prompting modules, and scoring images.
        validation_loop: Run the validation loop continuously based on the provided settings.
    """

    def __init__(
        self,
        key: Keypair,
        netuid: int,
        client: CommuneClient,
        call_timeout: int = 60,
    ) -> None:
        super().__init__()
        self.client = client
        self.key = key
        self.netuid = netuid
        self.call_timeout = call_timeout

        # Initialize BLIP for image description
        self.blip_processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
        self.blip_model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")
        self.blip_model.to("cuda" if torch.cuda.is_available() else "cpu")

        # Initialize CLIP for prompt-image comparison
        self.clip_processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
        self.clip_model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")
        self.clip_model.to("cuda" if torch.cuda.is_available() else "cpu")

    def get_addresses(self, client: CommuneClient, netuid: int) -> dict[int, str]:
        """
        Retrieve all module addresses from the subnet.

        Args:
            client: The CommuneClient instance used to query the subnet.
            netuid: The unique identifier of the subnet.

        Returns:
            A dictionary mapping module IDs to their addresses.
        """
        # Makes a blockchain query for the miner addresses
        module_addresses = client.query_map_address(netuid)
        return module_addresses

    def _get_miner_image(
        self,
        prompt: str,
        miner_info: tuple[list[str], Ss58Address],
    ) -> str | None:
        """
        Prompt a miner module to generate an image based on the given prompt.

        Args:
            prompt: The prompt to give the miner module.
            miner_info: A tuple containing the miner's connection information and key.

        Returns:
            The path to the generated image from the miner module, or None if the miner fails to generate an image.
        """
        connection, miner_key = miner_info
        module_ip, module_port = connection
        client = ModuleClient(module_ip, int(module_port), self.key)
        try:
            # handles the communication with the miner
            miner_response = asyncio.run(
                client.call(
                    "generate",
                    miner_key,
                    {"prompt": prompt},
                    timeout=self.call_timeout,  # Â type: ignore
                )
            )
            image_path = miner_response["image_path"]

        except Exception as e:
            log(f"Miner {module_ip}:{module_port} failed to generate an image")
            print(e)
            image_path = None
        return image_path

    def _score_miner(self, image_path: str | None, prompt: str) -> float:
        """
        Score the generated image by comparing its description to the prompt.

        Args:
            image_path: The path to the generated image from the miner module.
            prompt: The original prompt given to the miner module.

        Returns:
            The score assigned to the miner's image, based on how well the description matches the prompt.
        """
        if not image_path:
            return 0

        # Load and prepare the image
        image = Image.open(image_path)

        # Generate the description of the image using BLIP
        inputs = self.blip_processor(image, return_tensors="pt").to(self.blip_model.device)
        description = self.blip_model.generate(**inputs)
        description_text = self.blip_processor.decode(description[0], skip_special_tokens=True)

        # Use CLIP to compare the prompt with the generated description
        inputs = self.clip_processor(text=prompt, images=image, return_tensors="pt", padding=True).to(self.clip_model.device)
        outputs = self.clip_model(**inputs)
        logits_per_image = outputs.logits_per_image
        score = logits_per_image.item()  # Higher score means better alignment

        # Normalize score to be between 0 and 1
        return min(max(score / 100.0, 0), 1)

    def get_miner_prompt(self) -> str:
        """
        Generate a prompt for the miner modules.

        Returns:
            The generated prompt for the miner modules.
        """
        # Implement your custom prompt generation logic here
        return "A futuristic cityscape with flying cars at sunset."

    async def validate_step(
        self, syntia_netuid: int, settings: ValidatorSettings
    ) -> None:
        """
        Perform a validation step.

        Generates prompts based on the provided settings, prompts modules to generate images,
        and scores the generated images against the prompts.

        Args:
            syntia_netuid: The network UID of the subnet.
        """

        # Retrieve the miner information
        modules_addresses = self.get_addresses(self.client, syntia_netuid)
        modules_keys = self.client.query_map_key(syntia_netuid)
        val_ss58 = self.key.ss58_address
        if val_ss58 not in modules_keys.values():
            raise RuntimeError(f"Validator key {val_ss58} is not registered in subnet")

        modules_info: dict[int, tuple[list[str], Ss58Address]] = {}

        modules_filtered_address = get_ip_port(modules_addresses)
        for module_id in modules_keys.keys():
            module_addr = modules_filtered_address.get(module_id, None)
            if not module_addr:
                continue
            modules_info[module_id] = (module_addr, modules_keys[module_id])

        score_dict: dict[int, float] = {}

        miner_prompt = self.get_miner_prompt()
        get_miner_image = partial(self._get_miner_image, miner_prompt)

        log(f"Selected the following miners: {modules_info.keys()}")

        with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
            it = executor.map(get_miner_image, modules_info.values())
            miner_images = [*it]

        for uid, image_path in zip(modules_info.keys(), miner_images):
            if not image_path:
                log(f"Skipping miner {uid} that didn't provide an image")
                continue

            score = self._score_miner(image_path, miner_prompt)
            time.sleep(0.5)
            # Score has to be lower or equal to 1, as one is the best score, you can implement your custom logic
            assert score <= 1
            score_dict[uid] = score

        if not score_dict:
            log("No miner managed to provide a valid image")
            return None

        # The blockchain call to set the weights
        _ = set_weights(settings, score_dict, self.netuid, self.client, self.key)

    def validation_loop(self, settings: ValidatorSettings) -> None:
        """
        Run the validation loop continuously based on the provided settings.

        Args:
            settings: The validator settings to use for the validation loop.
        """
        while True:
            start_time = time.time()
            _ = asyncio.run(self.validate_step(self.netuid, settings))

            elapsed = time.time() - start_time
            if elapsed < settings.iteration_interval:
                sleep_time = settings.iteration_interval - elapsed
                log(f"Sleeping for {sleep_time}")
                time.sleep(sleep_time)
